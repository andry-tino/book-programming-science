%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%
%%
%% Andrea Tino - 2019
%% Programming + Science
%% Opinion model
%%
%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%

\section{Building our first CA: Conway's Game of Life}
\label{sec:simpleca}

We want to create our first CA in code so that we can display the cells and see them changing
state. In this section, we will build the basic architecture of a CA that can be used to build any
CA in future. For this, we are going to use the latest web technologies to create web sites and
web applications in the browser: Javascript, HTML and CSS.

\subsection{Creating the basic project structure}
In our PC, let's create a directory (anywhere you want, on your Desktop maybe?) and give it
a cool name like: \texttt{cellautom}. Inside this new directory, do the following:

\begin{enumerate}
\item Create a file and name it: \texttt{index.html}.
\item Create a file and name it: \texttt{ca.js}.
\item Create one last file and name it: \texttt{style.css}.
\end{enumerate}

These three files represent the basic organization of our visual CA we are going to develop.
Table \ref{tab:files} offers a good overview of what they are needed for.

%
% Table
%
\begin{table}[!t]
\centering
\caption{Please write your table caption here}
\label{tab:files}
%
% Follow this input for your own table layout
%
\begin{tabular}{p{0.2\textwidth}p{0.2\textwidth}p{0.5\textwidth}}
\hline\noalign{\smallskip}
File & Type & Description \\
\noalign{\smallskip}\svhline\noalign{\smallskip}
\texttt{index.html} & Web page & This is the web pae that will display the CA and its evolution.\\
\texttt{ca.js} & Javascript code file  & This file will contain the J
    avascript code that will make the CA appear and evolve.\\
\texttt{style.css} & CSS Stylesheet  & The stylesheet we will use to apply colors, fonts 
    and make our CA beautiful.\\
\noalign{\smallskip}\hline\noalign{\smallskip}
\end{tabular}
\end{table}
%

% Figure
%
\begin{figure}[b]
\sidecaption
% tikz diagram
\input{diag-dirstruct1}
%
% If not, use
%\picplace{5cm}{2cm} % Give the correct figure height and width in cm
%
\caption{Your project folder should look like this.}
\label{fig:dirstruct1}
\end{figure}
%

\subsection{Defining the barebones}
Time to write some initial code to see something appearing on the page once we run in the browser.
Open file \texttt{index.html} with tyour favorite editor and input this code:

\begin{programcode}{index.html}
Write this code minding casing and spacing.
\begin{codehtml}
<!DOCTYPE html>
<html>
<head>
  <title>My Cellular Automaton</title>
</head>

<body>
  Hello world!
</body>
</html>
\end{codehtml}
\end{programcode}

Save the file and now try to open it in your browser.

\begin{tips}{A first glance at HTML}
The code we just wrote is read by the browser to create a graphical visualization. HTML is used to
create web pages. It is not a \textit{programming language} (it does not tell a computer what to do),
but a \textit{markup language} (it tells a computer what to display and paint on the screen).

A minimal HTML page is exactly the one we wrote. It is all based on the concept of \textit{tags}. The
first line \texttt{<!DOCTYPE html>} is special and tells the browser that we are using the latest
version of HTML (you should always use this). Then a new tag \texttt{<html>} is opened and is
closed at the end of the file: \texttt{</html>}. An opening tag and a closing tag make a \textit{block}.
Blocks can contain other blocks.

The \texttt{<html>} block must contain, in order, two other blocks:
\texttt{<head>} and \texttt{<body>}. The first block contains the block for defining the title of the page
(this text is displayed on the browser's top bar). Everything inside \texttt{<head>} will not generate any 
graphics, it only contains information about the page. What's inside \texttt{body} is, on the other hand, 
painted (or, more technically speaking, rendered\footnote{The term \textit{render} is used to indicate
the complex set of operations that a program does in order to visualize something on the screen.})
inside the browser window. As you can see, we only have a piece of 
text\footnote{The \textit{Hello World} is, historically, the first thing one learns
to do when learning a new programming language, we had to respect tradition here.}, which
is in fact rendered on a blank, empty page.
\end{tips}

Of course we don't want to just display text, we want to render a full CA! So, in the same file, replace
that text.

\begin{programcode}{index.html (snippet)}
Remove \texttt{Hello world!} and insert a \texttt{<div>} block instead.
\begin{codehtml}
<body>
  <div id="ca"></div>
</body>
\end{codehtml}
\end{programcode}

A \texttt{<div>} block is used to group things. We are going to write some code that puts some graphics
inside it. Before leaving this file, we need to import inside it the other two files we have created.

\begin{programcode}{index.html (snippet)}
Place these new tags right below block \texttt{<title>}.
\begin{codehtmlh1}{2}{5}
<head>
  <title>My Cellular Automaton</title>
  <script src="ca.js"></script>
  <link rel="stylesheet" href="style.css">
</head>
\end{codehtmlh1}
\end{programcode}

The first new tag we have added is a \texttt{<script>} which instructs the browser to load and run the
Javascript code inside \texttt{ca.js}. The next one is a \texttt{<link>} tag (this one does not have a closing tag)
and tells the browser to load the styles defined inside \texttt{style.css}. As of now, if you refresh the
page in the browser, you will just see a blank page (not for long!).

\subsection{Creating the grid}
For now we are done with \texttt{index.html}; the next staep is to write the code to render the CA
in our page. To do this, let's open \texttt{ca.js} and insert the first lines of code.

\begin{programcode}{ca.js}
These first lines of Javascript code create our \textit{module}.
\begin{code}
(function(){
  // This is a module
})();
\end{code}
\end{programcode}

We have just created a \textit{module}, let's try to understand a bit more about them.

\begin{tips}{Javascript modules}
Javascript language does not have an intrinsic concept of module, this is something programmers create in
different ways. A \textit{module} is a programming structure encapsulating some code that is isolated
from other codes running in the page.

It is a very generic definition because there is really not much more about it. For now, everytime
we write some code that needs to run in the page, we will wrap it inside a module like shown before,
this is a standard procedure to make sure other Javascript codes on the page, in future, do not
affect our code.
\end{tips}

We have imported \texttt{ca.js} inside \texttt{index.html}, so when we refresh the page the module
we wrote will run. However, since there is really no code inside the module (just a comment),
nothing will happen. Our objective here is to render a grid of cells which will be our automaton,
to achieve this, let's start by defining a few constants:

\begin{programcode}{ca.js}
Define the constants we will use at the beginning on the module.
\begin{codeh1}{1}{5}
(function(){
  const rowsnum = 9;
  const colsnum = 9;
  const cellsize = 20; // In px
})();
\end{codeh1}
\end{programcode}

The constants we defined will be used to create an automaton of the size we specify in 
\texttt{rowsnum} and \texttt{colsnum}. Constant \texttt{cellsize} will be used to defined the
width and height of each (square) cell. Moving on, we now want to create the code that renders the grid.

\begin{programcode}{ca.js}
Inside the module, after the constants, add a function and the code to invoke it.
\begin{codeh1}{5}{13}
(function(){
  const rowsnum = 9;
  const colsnum = 9;
  const cellsize = 20; // In px

  function create() {
    // Here the code to create the grid
  }

  window.addEventListener("load", function() {
    create();
  });
})();
\end{codeh1}
\end{programcode}

We have added two things: we have defined function \texttt{create}, and we have added some code in
the module that uses \texttt{window.addEventListener}. This is what happens when we run the page:

\begin{enumerate}
\item The module is executed.
\item Function \texttt{window.addEventListener} is run. This code will register a function (the one
passed as second parameter), once the event specified in the first parameter fires.
\item When the page has finished loading and everything is ready, function \texttt{create} is called.
\end{enumerate}

If we didn't use \texttt{window.addEventListener}, but just executed \texttt{create()}, our
application might error sometimes. This code guarantees that we start doing things only when
the page is fully loaded; we need this guard and it is always good to have.

\begin{programcode}{ca.js (snippet)}
Add a new function after function \texttt{create} inside the module.
\begin{codeh1}{4}{8}
function create() {
  // Here the code to create the grid
}

function getContainer() {
  return document.getElementById("ca");
}
\end{codeh1}
\end{programcode}

Function \texttt{getContainer} is going to be important for us later. The function simply
uses \texttt{document.getElementById} to retrieve the \texttt{<div>} we added before in
\texttt{index.html} (we do this by using the \texttt{id} property on the tag).
At this point, we are ready to fill function
\texttt{create} with the code which renders the grid inside the page.

\begin{programcode}{ca.js (snippet)}
Focusing on function \texttt{create}, remove the comment and add this code instead.
\begin{codeh1}{1}{16}
function create() {
  let container = getContainer();
  container.style.width = (colsnum * cellsize + colsnum) + "px";

  for (let i = 1; i <= rowsnum; i++) {
    for (let j = 1; j <= colsnum; j++) {
      let cell = document.createElement("div");
      cell.id = i + ":" + j;
      cell.classList.add("cell");
      cell.style.width = cellsize + "px";
      cell.style.height = cellsize + "px";

      container.appendChild(cell);
    }
  }
}
\end{codeh1}
\end{programcode}

The code above does a few things. In the first lines, we get a reference to the CA container
(the \texttt{<div>} in the page), and set its width according to the size we specified in the
constants. Later on, we create a row-by-column scanning by using one loop nested into the other.
The outer loop will be used to set the current row, the inner loop to set the column. The code
inside the two loops will be executed $\text{rowsnum} \cdot \text{colsnum}$ times
(for each cell to create).

The code inside the loops first creates a \texttt{<div>} block, then assigns it an id (very
important step, so that we can reference each cell later
by using \texttt{document.getElementById}), adds a style class to it and defines its width and height.
The last command invokes \texttt{appendChild} on the container: this will make the cell appear
inside the container.\\

Try to refresh the page! What can you see? Not really what we were hoping right? Well, the fact that
we cannot see mush does not mean that the page is empty. Let's have a look by inspecting the page
using the F12 tool. If we do so, the tool will display, under the \textit{Elements} tab, the
content of the page: our \texttt{<div>}s are there, it's just that the browser is not rendering
them on the page the way we want. The problem is styling, we must properly style the elements we
have created by using some CSS.

\begin{programcode}{style.css}
Insert this code in \texttt{style.css}.
\begin{codecss}
body {
  margin: 10x;
  padding: 10px;
}

#ca {
  background-color: #000;
  display: flex;
  flex-wrap: wrap;
  padding-left: 1px;
  padding-top: 1px;
}

.cell {
  border: none;
  background-color: #fff;
  margin-right: 1px;
  margin-bottom: 1px;
  flex: 0 0 auto;
}
\end{codecss}
\end{programcode}

We have filled the stylesheet with 3 sets of rules. The first set is for the \texttt{<body>} element
and just defines a 10 pixel spacing between the borders and the content. The second targets
all elements with \texttt{id="ca"} which is our container; we set the background to black and
make sure contained cells are wrapped by using \texttt{display: flex} and \texttt{flex-wrap: wrap}.

If you try to refresh the page now, you will see the grid!

\begin{trailer}{Media content}
You can find the code for this project up to this point in folder \texttt{v2.3}.
\end{trailer}

\begin{problem}
\label{prob:changecasize}
Change the size of the CA/grid by setting it to different dimensions. Also try to make rectangular CAs, not
just square grids.
\end{problem}

\subsection{Coding the evolution logic}
We have succeeded rendering the CA, but at the moment our CA doesn't do much, it does nothing!
The key feature of CA is, as we learned at the beginning of this chapter, their ability to
\textit{evolve}. We need to write down that
logic\footnote{Developers use the term \textit{logic} a lot to refer to a behavior that they need
to develop for an application. In our case, we need to code the behavior of evolution in the CA,
so that it can change configuration during every cycle. You can replace the word
\textit{behavior} with \textit{logic}, as many among software engineers and programmers like to
use the latter in their everyday jargon.}.

But what kind of CA are we going to build? What is the state going to be? How about the neighborhood? We
need to define all these properties. The CA we are going to build is a simple and very famour one called:
\textit{Conway's Game of Life} \cite{wolfram-ca}. This CA has the following characteristics:

\begin{itemize}
\item The set of states (alphabet) is: $\mathcal{A} = \{ 0, 1 \}$, where $0$ means "off" (inactive, dead) and
$1$ means "on" (active, alive).
\item Each cell has a Moore neighborhood (recall definition \ref{def:neighmoore} and example \ref{ex:simpleca}).
\item The CA describes pixels in a screen. When a pixel (cell) is on, it turns black; when it's off, it
turns white. 
\end{itemize}

This CA was the first ever published in the history of Mathematics, and it has very interesting properties.

\subsubsection{Setting the initial state}
In CA, it is crucial that we are able to set the initial condition (remember what we talked about in
theorem \ref{theo:evinitcond}). To do so, let's add this code.

\begin{programcode}{ca.js (snippet)}
Insert this constant in \texttt{ca.js} right after the existing contants at the beginning of the module.
\begin{codeh1}{1}{3}
const cellsize = 20; // In px
const initConfig = ["2:2", "4:7", "7:4", "5:5", "3:8"];
\end{codeh1}
\end{programcode}

The line we have added defines a constant which will hold the array of cell identifiers with an initial state
of $1$ in the CA. The code we have at the moment simply creates the cells, as soon as we finish rendering the grid,
we must set the initial state.

\begin{programcode}{ca.js (snippet)}
Add this function just below function \texttt{create} inside the module.
\begin{code}
function initializeGrid() {
  for (let i = 1; i <= rowsnum; i++) {
    for (let j = 1; j <= colsnum; j++) {
      if (initConfig.indexOf(i + ":" + j) >= 0) {
        set(i, j, 1);
      } else {
        set(i, j, 0);
      }
    }
  }
}
\end{code}
\end{programcode}

We are going to invoke \texttt{initializeGrid} right after the grid is rendered. As you can see, we traverse
all cells by scanning them row by column as we did before. Inside both loops, we invoke function \texttt{set}
(this function does not exist yet, we will write it in a moment) which will configure the cell state to either
$0$ or $1$ depending on whether the cell identifier is in the \texttt{initConfig} list or not. This will allow us
to set the initial configuration of the CA.

\begin{important}{Bottom-up vs. top-down programming}
We cannot execute the code at this time yet because we still need to write function \texttt{set}.
This approach we have chosen now is a bit different from before. Previously, if, say, function $A$ had to
be called inside function $B$, we would write function $A$ first, and then write down function $B$. Now we are
doing the opposite. The first approach is called \textit{bottom-up programming}
as we build from the foundations and the adding on top.
The latter is called \textit{top-down programming} because we start from the higher levels, then moving down
writing what's needed.

The good thing of bottom-up coding is that it's possible to test radually every step, but the final code takes
shape later. On the other end, top-down programming is cumbersome because we cannot test our progress until
all the layers have been built, but the code takes the final shape from the very beginning.
\end{important}

We have written the function responsible for initializing the CA, but we have only defined it, no place in code
is invoking it. We need to invoke it, where? As we mentioned, this phase must occur right after the grid is
rendered; who renders the grid? That would be function \texttt{create}, and who calls that function? If you
scroll down in \texttt{ca.js}, you see that, at the end of the module, the module itself calls it!

\begin{programcode}{ca.js (snippet)}
Invoke function \texttt{initializeGrid} right after calling \texttt{create}.
\begin{codeh1}{2}{4}
window.addEventListener("load", function(){
  create();
  initializeGrid();
});
\end{codeh1}
\end{programcode}

At this point we have almost everything, as soon as the page starts, the grid is created and then
\texttt{initializeGrid} will be called to set the initial state. However that function is trying to
call \texttt{set}, which is another function we still need to define. The purpose of function
\texttt{set(row, column, value)} will be to set the value of the cell at position
$(\text{row}, \text{column})$ to the value in parameter \texttt{value}: $0$ means off and $1$ means on.

\begin{programcode}{ca.js (snippet)}
Add this function right below \texttt{initializeGrid}.
\begin{code}
function set(i, j, value) {
  let cell = getCell(i, j);
  cell.setAttribute("data-value", value);
}
\end{code}
\end{programcode}

The function will first try to get the HTML element of the cell, and then it will try to set attribute
\texttt{data-value} to that. As you can see, here as well we are doing top-down programming because
function \texttt{getCell} does not yet exist, we need to write it.

\begin{programcode}{ca.js (snippet)}
Add this function right above \texttt{set}.
\begin{code}
function getCell(i, j) {
  return document.getElementById(i + ":" + j);
}
\end{code}
\end{programcode}

When we created the grid, we set an identifier to every cell element. Function \texttt{document.getElementById}
is present in every browser and it returns the first HTML element whose \texttt{id} corresponds to the one
provided as input. At this point it seems like everything is done, so try and refresh the page; unfortunately
you will not see anything different. Did we make any mistake? Let's try to see.

\begin{enumerate}
\item Open the browser and refresh the page. You should see the grid.
\item Open the F12 tools and navigate to the \textit{Elements} panel.
\item Expand the \texttt{<body>} tag. Also expand the \texttt{<div id="ca" ...>} tag.
\end{enumerate}

You should, at this point, see the list of \texttt{<div>} tags that represent the cells. See how, in correspondance
of the IDs in array \texttt{initConfig}, the tag shows \texttt{data-value="1"} and \texttt{data-value="0"}
otherwise. So our logic is actually working. The actual problem, is the styling. We want the cells marked with
\texttt{data-value="1"} to appear as black, and not white. So let's head to \texttt{style.css} and make some
modifications.

\begin{programcode}{style.css (snippet)}
Add this code at the bottom of the file.
\begin{codecss}
.cell[data-value="1"] {
  background-color: #000;
}
\end{codecss}
\end{programcode}

Make sure you always save. The code we just added instructs the browser to apply a black background color
to our cells when their HTML elements have attribute \texttt{data-value} set to \texttt{1}.
Now our code is finished and we can refresh the page to see our CA getting an initial
condition.

\begin{problem}
\label{prob:changeinit}
Change the initial condition of the grid. Set to \textit{on} only the following
cells: $(3,1)$, $(1,3)$ and $(4,4)$.
\end{problem}

\subsubsection{Building the UI}
At this point we have succeeded setting the initial condition. This means that we can configure the CA however
we want by just changing array \texttt{initConfig} at the beginning of the module. Our final goal is to
make the CA evolve and see it as it changes. We need to build a \textit{User Interface} (or simply: \textit{UI})
that gives us the ability to:

\begin{enumerate}
\item Render the CA in its next configurartion. We can accomplish this with a button: every time we
click on this button, the CA will shift to its next configuration from the current one.
\item Visualize what iteration we are in. We can create a piece of text that displays a number
representing the index of the current configuration (discrete time).
\end{enumerate}

So we basically need to create 2
\textit{controls}\footnote{A web page, or more generally, a user interface in every application or app, is made
of different things: buttons, texts, text boxes, input fields and so on. Each one of them is a piece of the UI,
one common way to refer to them is by using the word: \textit{control} in design jargon.}: one button and
one text label. We want to display them at the bottom of the grid, on the left.

\begin{programcode}{index.html (snippet)}
Add a new \texttt{<div>} block right after the one containing the CA.
\begin{codehtmlh1}{2}{5}
<body>
  <div id="ca"></div>
  <div class="controls">
  </div>
</body>
\end{codehtmlh1}
\end{programcode}

The new \texttt{<div>} we just added will be the container for our button and text label. Next step
is adding them inside their container.

\begin{programcode}{index.html (snippet)}
Place these new lines inside the \texttt{<div>} block we added before.
\begin{codehtmlh1}{1}{4}
<div class="controls">
  <button id="buttonNext">Next</button>
  <span id="cycleText"></span>
</div>
\end{codehtmlh1}
\end{programcode}

Tag \texttt{<button>} creates, as you probably already figured out, a button. While tag \texttt{<span>}
is used to show text. If you go ahead and refresh the page, you will see the button but you not see
the label next to it. That is because we need to put some text inside it. Since the text in the label
must show the current CA's iteration, we need to track time.

\begin{programcode}{ca.js (snippet)}
Create a variable in the module right after constant \texttt{initConfig} (add spaces before and after to
have a nice code formatting by separating constants, variables and functions in the module).
\begin{codeh1}{3}{5}
const cellsize = 20; // In px
const initConfig = ["3:4", "3:5", "4:3", "4:4", "5:4"];

let t = 0; // Cycles (time)

function create() {
\end{codeh1}
\end{programcode}

Variable \texttt{t} will keep track of time by storing the current CA's iteration. As you can see, when the
module starts, its initial value is set to \texttt{0}, because the initial configuration is cycle 0!
Now we need to show the value of \texttt{t} in the label we just created. To do this, we create a function
which will update the label text:

\begin{programcode}{ca.js (snippet)}
Add this function in the last part of the module.
\begin{codeh1}{0}{5}
function updateCycleText() {
  let text = document.getElementById("cycleText");
  text.textContent = "cycle " + t;
}

window.addEventListener("load", function () {
\end{codeh1}
\end{programcode}

As you can see, function \texttt{updateCycleText} will first locate the label in our page by using
\texttt{document.getElementById} and ID \texttt{"cycleText"} we placed on that element; so that later
we can access the element's \texttt{textContent} and set it to the value we want. We will invoke
this function everytime the CA moves to the next configuration but also when the CA is first created.
This last part we can actually do now.

\begin{programcode}{ca.js (snippet)}
Invoke function \texttt{updateCycleText} right after we call the function to initialize the grid in
the last part of the module.
\begin{codeh1}{3}{5}
window.addEventListener("load", function () {
  create();
  initializeGrid();
  updateCycleText();
});
\end{codeh1}
\end{programcode}

If we refresh the page now, we will see the label next to the button showing text: "cycle 0". Of course,
if we press the button, nothing happens because we haven't written anything for that yet, so let's add
the code to react and do something when the button is clicked.

\begin{programcode}{ca.js (snippet)}
Add this function in the module right after function \texttt{initializeGrid}.
\begin{code}
function initializeButton() {
  let button = document.getElementById("buttonNext");
  button.addEventListener("click", function(){
    console.log("You have clicked me!");
  });
}
\end{code}
\end{programcode}

This function will search for the button element in the page and then add a listener for the \texttt{click}
event. It means that the function we pass as second parameter to \texttt{addEventListener} will be executed
every time the button is clicked. At the  moment we will just display a message in the console. We
of course need to call function \texttt{initializeButton} to make this happen, we invoke the function
right after the grid has been initialized.

\begin{programcode}{ca.js (snippet)}
Invoke function \texttt{initializeButton} right after we call the function to initialize the grid in
the last part of the module.
\begin{codeh1}{3}{5}
window.addEventListener("load", function () {
  create();
  initializeGrid();
  initializeButton();
  updateCycleText();
});
\end{codeh1}
\end{programcode}

If you refresh the page, make sure the F12 tools are open and visible on your screen, and click the button,
you will the message appearing in the console.

\subsubsection{Coding the evolution}
Everything is prepared now. We have the CA initialized and we also have the UI to interact with the CA.
Next step is to create the logic to make the the CA evolve.
This piece of code will be executed when we press the button.

\subsubsection{Final touches}
Todo
