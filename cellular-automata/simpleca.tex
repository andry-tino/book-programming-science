%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%
%%
%% Andrea Tino - 2019
%% Programming + Science
%% Opinion model
%%
%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%

\section{Building our first CA: Conway's Game of Life}
\label{sec:simpleca}

We want to create our first CA in code so that we can display the cells and see them changing
state. In this section, we will build the basic architecture of a CA that can be used to build any
CA in future. For this, we are going to use the latest web technologies to create web sites and
web applications in the browser: Javascript, HTML and CSS.

\subsection{Creating the basic project structure}
In our PC, let's create a directory (anywhere you want, on your Desktop maybe?) and give it
a cool name like: \texttt{cellautom}. Inside this new directory, do the following:

\begin{enumerate}
\item Create a file and name it: \texttt{index.html}.
\item Create a file and name it: \texttt{ca.js}.
\item Create one last file and name it: \texttt{style.css}.
\end{enumerate}

These three files represent the basic organization of our visual CA we are going to develop.
Table \ref{tab:files} offers a good overview of what they are needed for.

%
% Table
%
\begin{table}[!t]
\centering
\caption{Please write your table caption here}
\label{tab:files}
%
% Follow this input for your own table layout
%
\begin{tabular}{p{0.2\textwidth}p{0.2\textwidth}p{0.5\textwidth}}
\hline\noalign{\smallskip}
File & Type & Description \\
\noalign{\smallskip}\svhline\noalign{\smallskip}
\texttt{index.html} & Web page & This is the web pae that will display the CA and its evolution.\\
\texttt{ca.js} & Javascript code file  & This file will contain the J
    avascript code that will make the CA appear and evolve.\\
\texttt{style.css} & CSS Stylesheet  & The stylesheet we will use to apply colors, fonts 
    and make our CA beautiful.\\
\noalign{\smallskip}\hline\noalign{\smallskip}
\end{tabular}
\end{table}
%

% Figure
%
\begin{figure}[b]
\sidecaption
% tikz diagram
\input{diag-dirstruct1}
%
% If not, use
%\picplace{5cm}{2cm} % Give the correct figure height and width in cm
%
\caption{Your project folder should look like this.}
\label{fig:dirstruct1}
\end{figure}
%

\subsection{Defining the barebones}
Time to write some initial code to see something appearing on the page once we run in the browser.
Open file \texttt{index.html} with tyour favorite editor and input this code:

\begin{programcode}{index.html}
Write this code minding casing and spacing.
\begin{verbatim}
<!DOCTYPE html>
<html>
<head>
  <title>My Cellular Automaton</title>
</head>

<body>
  Hello world!
</body>
</html>
\end{verbatim}
\end{programcode}

Save the file and now try to open it in your browser.

\begin{tips}{A first glance at HTML}
The code we just wrote is read by the browser to create a graphical visualization. HTML is used to
create web pages. It is not a \textit{programming language} (it does not tell a computer what to do),
but a \textit{markup language} (it tells a computer what to display and paint on the screen).

A minimal HTML page is exactly the one we wrote. It is all based on the concept of \textit{tags}. The
first line \texttt{<!DOCTYPE html>} is special and tells the browser that we are using the latest
version of HTML (you should always use this). Then a new tag \texttt{<html>} is opened and is
closed at the end of the file: \texttt{</html>}. An opening tag and a closing tag make a \textit{block}.
Blocks can contain other blocks.

The \texttt{<html>} block must contain, in order, two other blocks:
\texttt{<head>} and \texttt{<body>}. The first block contains the block for defining the title of the page
(this text is displayed on the browser's top bar). Everything inside \texttt{<head>} will not generate any 
graphics, it only contains information about the page. What's inside \texttt{body} is, on the other hand, 
painted (or, more technically speaking, rendered\footnote{The term \textit{render} is used to indicate
the complex set of operations that a program does in order to visualize something on the screen.})
inside the browser window. As you can see, we only have a piece of 
text\footnote{The \textit{Hello World} is, historically, the first thing one learns
to do when learning a new programming language, we had to respect tradition here.}, which
is in fact rendered on a blank, empty page.
\end{tips}

Of course we don't want to just display text, we want to render a full CA! So, in the same file, replace
that text.

\begin{programcode}{index.html (snippet)}
Remove \texttt{Hello world!} and insert a \texttt{<div>} block instead.
\begin{verbatim}
<body>
  <div id="ca"></div>
</body>
\end{verbatim}
\end{programcode}

A \texttt{<div>} block is used to group things. We are going to write some code that puts some graphics
inside it. Before leaving this file, we need to import inside it the other two files we have created.

\begin{programcode}{index.html (snippet)}
Place these new tags right below block \texttt{<title>}.
\begin{verbatim}
<head>
  <title>My Cellular Automaton</title>
  <script src="ca.js"></script>
  <link rel="stylesheet" href="style.css">
</head>
\end{verbatim}
\end{programcode}

The first new tag we have added is a \texttt{<script>} which instructs the browser to load and run the
Javascript code inside \texttt{ca.js}. The next one is a \texttt{<link>} tag (this one does not have a closing tag)
and tells the browser to load the styles defined inside \texttt{style.css}. As of now, if you refresh the
page in the browser, you will just see a blank page (not for long!).

\subsection{Creating the grid}
For now we are done with \texttt{index.html}; the next staep is to write the code to render the CA
in our page. To do this, let's open \texttt{ca.js} and insert the first lines of code.

\begin{programcode}{ca.js}
These first lines of Javascript code create our \textit{module}.
\begin{verbatim}
(function(){
  // This is a module
})();
\end{verbatim}
\end{programcode}

We have just created a \textit{module}, let's try to understand a bit more about them.

\begin{tips}{Javascript modules}
Javascript language does not have an intrinsic concept of module, this is something programmers create in
different ways. A \textit{module} is a programming structure encapsulating some code that is isolated
from other codes running in the page.

It is a very generic definition because there is really not much more about it. For now, everytime
we write some code that needs to run in the page, we will wrap it inside a module like shown before,
this is a standard procedure to make sure other Javascript codes on the page, in future, do not
affect our code.
\end{tips}

We have imported \texttt{ca.js} inside \texttt{index.html}, so when we refresh the page the module
we wrote will run. However, since there is really no code inside the module (just a comment),
nothing will happen. Our objective here is to render a grid of cells which will be our automaton,
to achieve this, let's start by defining a few constants:

\begin{programcode}{ca.js}
Define the constants we will use at the beginning on the module.
\begin{verbatim}
(function(){
  const rowsnum = 9;
  const colsnum = 9;
  const cellsize = 20; // In px
})();
\end{verbatim}
\end{programcode}

The constants we defined will be used to create an automaton of the size we specify in 
\texttt{rowsnum} and \texttt{colsnum}. Constant \texttt{cellsize} will be used to defined the
width and height of each (square) cell. Moving on, we now want to create the code that renders the grid.

\begin{programcode}{ca.js}
Inside the module, after the constants, add a function and the code to invoke it.
\begin{verbatim}
(function(){
  const rowsnum = 9;
  const colsnum = 9;
  const cellsize = 20; // In px

  function create() {
    // Here the code to create the grid
  }

  window.addEventListener("load", function(){
    create();
  });
})();
\end{verbatim}
\end{programcode}

We have added two things: we have defined function \texttt{create}, and we have added some code in
the module that uses \texttt{window.addEventListener}. This is what happens when we run the page:

\begin{enumerate}
\item The module is executed.
\item Function \texttt{window.addEventListener} is run. This code will register a function (the one
passed as second parameter), once the event specified in the first parameter fires.
\item When the page has finished loading and everything is ready, function \texttt{create} is called.
\end{enumerate}

If we didn't use \texttt{window.addEventListener}, but just executed \texttt{create()}, our
application might error sometimes. This code guarantees that we start doing things only when
the page is fully loaded; we need this guard and it is always good to have.

\begin{programcode}{ca.js (snippet)}
Add a new function after function \texttt{create} inside the module.
\begin{verbatim}
function create() {
  // Here the code to create the grid
}

function getContainer() {
  return document.getElementById("ca");
}
\end{verbatim}
\end{programcode}

Function \texttt{getContainer} is going to be important for us later. The function simply
uses \texttt{document.getElementById} to retrieve the \texttt{<div>} we added before in
\texttt{index.html} (we do this by using the \texttt{id} property on the tag).
At this point, we are ready to fill function
\texttt{create} with the code which renders the grid inside the page.

\begin{programcode}{ca.js (snippet)}
Focusing on function \texttt{create}, remove the comment and add these code instead.
\begin{verbatim}
function create() {
  let container = getContainer();
  container.style.width = (colsnum * cellsize + colsnum) + "px";

  for (let i = 1; i <= rowsnum; i++) {
    for (let j = 1; j <= colsnum; j++) {
      let cell = document.createElement("div");
      cell.id = i + ":" + j;
      cell.classList.add("cell");
      cell.style.width = cellsize + "px";
      cell.style.height = cellsize + "px";

      container.appendChild(cell);
    }
  }
}
\end{verbatim}
\end{programcode}

The code above does a few things. In the first lines, we get a reference to the CA container
(the \texttt{<div>} in the page), and set its width according to the size we specified in the
constants. Later on, we create a row-by-column scanning by using one loop nested into the other.
The outer loop will be used to set the current row, the inner loop to set the column. The code
inside the two loops will be executed $\text{rowsnum} \cdot \text{colsnum}$ times
(for each cell to create).

The code inside the loops first creates a \texttt{<div>} block, then assigns it an id (very
important step, so that we can reference each cell later
by using \texttt{document.getElementById}), adds a style class to it and defines its width and height.
The last command invokes \texttt{appendChild} on the container: this will make the cell appear
inside the container.\\

Try to refresh the page! What can you see? Not really what we were hoping right? Well, the fact that
we cannot see mush does not mean that the page is empty. Let's have a look by inspecting the page
using the F12 tool. If we do so, the tool will display, under the \textit{Elements} tab, the
content of the page: our \texttt{<div>}s are there, it's just that the browser is not rendering
them on the page the way we want. The problem is styling, we must properly style the elements we
have created by using some CSS.

\begin{programcode}{style.css}
Insert this code in \texttt{style.css}.
\begin{verbatim}
body {
  margin: 10x;
  padding: 10px;
}

#ca {
  background-color: #000;
  display: flex;
  flex-wrap: wrap;
  padding-left: 1px;
  padding-top: 1px;
}

.cell {
  border: none;
  background-color: #fff;
  margin-right: 1px;
  margin-bottom: 1px;
  flex: 0 0 auto;
}
\end{verbatim}
\end{programcode}

We have filled the stylesheet with 3 sets of rules. The first set is for the \texttt{<body>} element
and just defines a 10 pixel spacing between the borders and the content. The second targets
all elements with \texttt{id="ca"} which is our container; we set the background to black and
make sure contained cells are wrapped by using \texttt{display: flex} and \texttt{flex-wrap: wrap}.

If you try to refresh the page now, you will see the grid!

\begin{problem}
\label{prob:changecasize}
Change the size of the CA/grid by setting it to different dimensions. Also try to make rectangular CAs, not
just square grids.
\end{problem}

\subsection{Coding the evolution logic}
We have succeeded rendering the CA, but at the moment our CA doesn't do much, it does nothing!
The key feature of CA is, as we learned at the beginning of this chapter, their ability to
\textit{evolve}. We need to write down that
logic\footnote{Developers use the term \textit{logic} a lot to refer to a behavior that they need
to develop for an application. In our case, we need to code the behavior of evolution in the CA,
so that it can change configuration during every cycle. You can replace the word
\textit{behavior} with \textit{logic}, as many among software engineers and programmers like to
use the latter in their everyday jargon.}.

But what kind of CA are we going to build? What is the state going to be? How about the neighborhood? We
need to define all these properties. The CA we are going to build is a simple and very famour one called:
\textit{Conway's Game of Life} \cite{wolfram-ca}. This CA has the following characteristics:

\begin{itemize}
\item The set of states (alphabet) is: $\mathcal{A} = \{ 0, 1 \}$, where $0$ means "off" (inactive, dead) and
$1$ means "on" (active, alive).
\item Each cell has a Moore neighborhood (recall definition \ref{def:neighmoore} and example \ref{ex:simpleca}).
\item The CA describes pixels in a screen. When a pixel (cell) is on, it turns black; when it's off, it
turns white. 
\end{itemize}

This CA was the first ever published in the history of Mathematics, and it has very interesting properties.

\subsubsection{Setting the initial state}
In CA, it is crucial that we are able to set the initial condition (remember what we talked about in
theorem \ref{theo:evinitcond}). To do so, let's add this code.

\begin{programcode}{ca.js (snippet)}
Insert this constant in \texttt{ca.js} right after the existing contants at the beginning of the module.
\begin{verbatim}
const cellsize = 20; // In px
const initConfig = ["2:2", "4:7", "7:4", "5:5", "3:8"];
\end{verbatim}
\end{programcode}

The line we have added defines a constant which will hold the array of cell identifiers with an initial state
of $1$ in the CA. The code we have at the moment simply creates the cells, as soon as we finish rendering the grid,
we must set the initial state.

\begin{programcode}{ca.js (snippet)}
Add this function just below function \texttt{create} inside the module.
\begin{verbatim}
function initializeGrid() {
  for (let i = 1; i <= rowsnum; i++) {
    for (let j = 1; j <= colsnum; j++) {
      if (initConfig.indexOf(i + ":" + j) >= 0) {
        set(i, j, 1);
      } else {
        set(i, j, 0);
      }
    }
  }
}
\end{verbatim}
\end{programcode}

We are going to invoke \texttt{initializeGrid} right after the grid is rendered. As you can see, we traverse
all cells by scanning them row by column as we did before. Inside both loops, we invoke function \texttt{set}
(this function does not exist yet, we will write it in a moment) which will configure the cell state to either
$0$ or $1$ depending on whether the cell identifier is in the \texttt{initConfig} list or not. This will allow us
to set the initial configuration of the CA.

\begin{important}{Bottom-up vs. top-down programming}
We cannot execute the code at this time because we still need to write function \texttt{set}.
This approach we have taken now is a bit different from before. Previously, if, say, function $A$ had to
be called inside function $B$, we would write function $A$ first, and then write down function $B$. Now we are
doing the opposite. The first approach is called \textit{bottom-up programming}
as we build from the foundations and the adding on top.
The latter is called \textit{top-down programming} because we start from the higher levels, then moving down
writing what's needed.

The good thing of bottom-up coding is that it's possible to test radually every step, but the final code takes
shape later. On the other end, top-down programming is cumbersome because we cannot test our progress until
all the layers have been built, but the code takes the final shape from the very beginning.
\end{important}

SET

GET

\subsubsection{Defining the neighborhood}
Todo

\subsubsection{Rendering cycles}
Todo
